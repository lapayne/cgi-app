# azure-pipelines.yml
# This pipeline implements a multi-stage CI/CD workflow for a Node.js application.
# It builds and tests the app, then deploys to SIT, UAT, and Production environments
# with a manual approval gate before Production.

trigger:
  branches:
    include:
      - main
      - release/* # Trigger on main and any release branch

pr:
  branches:
    include:
      - "*" # Validate all pull requests

variables:
  # General variables
  npm_config_cache: "$(Pipeline.Workspace)/.npm"

  # Docker-specific variables
  dockerRegistryServiceConnection: "ghcr"
  imageRepository: "your-app-name"
  tag: "$(Build.BuildId)"

pool:
  vmImage: "ubuntu-latest"

stages:
  - stage: Build
    displayName: "Build and Push"
    jobs:
      - job: BuildAndPush
        displayName: "Build, Test, and Push"
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: "18.x"
            displayName: "Install Node.js"

          - script: npm install
            displayName: "Install Dependencies"

          - script: |
              CI=true npm test -- --ci --reporters=default --reporters=jest-junit
            displayName: "Run Tests"
            env:
              JEST_JUNIT_OUTPUT_DIR: "$(Build.ArtifactStagingDirectory)/test-results"
              JEST_JUNIT_OUTPUT_NAME: "junit.xml"
            continueOnError: "false"

          - task: PublishTestResults@2
            condition: succeededOrFailed()
            displayName: "Publish Test Results"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "$(Build.ArtifactStagingDirectory)/test-results/junit.xml"
              mergeTestResults: true
              failTaskOnFailedTests: true # Fail the pipeline if any tests fail

          - script: npm run build
            displayName: "Build Application"

          - task: Docker@2
            displayName: "Build Docker Image"
            inputs:
              command: "build"
              dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
              tags: |
                $(tag)
                latest

          - task: Docker@2
            displayName: "Push Docker Image to GitHub Registry"
            inputs:
              containerRegistry: "$(dockerRegistryServiceConnection)"
              repository: "$(imageRepository)"
              command: "push"
              tags: |
                $(tag)
                latest

  - stage: DeploySIT
    displayName: "Deploy to SIT"
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployToSIT
        displayName: "SIT Deployment"
        environment: "SIT"
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying image $(imageRepository):latest to SIT environment..."
                    # In a real pipeline, use deployment tasks here (e.g., KubernetesManifest@1)
                - script: |
                    echo "Running integration tests against SIT environment..."
                    # Add your SIT test commands here
                    echo "SIT tests passed."

  - stage: DeployUAT
    displayName: "Deploy to UAT"
    dependsOn: DeploySIT
    condition: succeeded()
    jobs:
      - deployment: DeployToUAT
        displayName: "UAT Deployment"
        environment: "UAT"
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying image $(imageRepository):latest to UAT environment..."
                    # In a real pipeline, use deployment tasks here
                - script: |
                    echo "Running smoke tests against UAT environment..."
                    # Add your UAT test commands here
                    echo "UAT tests passed."

  - stage: DeployProduction
    displayName: "Deploy to Production"
    dependsOn: DeployUAT
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployToProduction
        displayName: "Production Deployment"
        environment:
          name: "Production"
          # You must configure a manual approval check for this environment in the Azure DevOps UI.
          # This gate will pause the pipeline until the approval is given.
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying image $(imageRepository):latest to Production environment..."
                    # In a real pipeline, use production deployment tasks here
